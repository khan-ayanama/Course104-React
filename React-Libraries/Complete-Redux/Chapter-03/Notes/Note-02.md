# Async Logic and Data Fetching

When dealing with asynchronous logic and data fetching in Redux Toolkit, the common practice is to use middleware, such as Redux Thunk, which allows you to write asynchronous logic in your Redux actions. Redux Toolkit simplifies the process with its built-in createAsyncThunk utility.

Here's a step-by-step guide on how to handle async logic and data fetching using Redux Toolkit:

* Install Required Packages:

Ensure you have Redux Toolkit and Redux Thunk installed:

```bash
    npm install @reduxjs/toolkit react-redux redux-thunk
```

* Create an Async Thunk:

In your Redux slice file, use createAsyncThunk to define an async action. For example, let's create an async thunk for fetching user data:

```javascript
    // userSlice.js

    import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';
    import api from 'your-api-library'; // Replace with your API library

    // Async thunk for fetching user data
    export const fetchUserData = createAsyncThunk('user/fetchUserData', async (userId) => {
    const response = await api.getUser(userId);
    return response.data;
    });

    // Create a slice with reducers
    const userSlice = createSlice({
    name: 'user',
    initialState: { data: null, loading: 'idle', error: null },
    reducers: {},
    extraReducers: (builder) => {
        builder
        .addCase(fetchUserData.pending, (state) => {
            state.loading = 'loading';
        })
        .addCase(fetchUserData.fulfilled, (state, action) => {
            state.loading = 'succeeded';
            state.data = action.payload;
        })
        .addCase(fetchUserData.rejected, (state, action) => {
            state.loading = 'failed';
            state.error = action.error.message;
        });
    },
    });

    export default userSlice.reducer;
```

This example uses createAsyncThunk to create the async action fetchUserData. The action will dispatch pending, fulfilled, or rejected actions based on the API call's status.

* Configure the Store:

Set up your Redux store, combining the reducer generated by createSlice:

```javascript
    // store.js

    import { configureStore } from '@reduxjs/toolkit';
    import userReducer from './userSlice'; // Import your user slice

    const store = configureStore({
    reducer: {
        user: userReducer,
        // Add other reducers as needed
    },
    middleware: (getDefaultMiddleware) =>
        getDefaultMiddleware({
        serializableCheck: false, // Disable serializable check for async actions
        }),
    });

    export default store;
```

Use in React Component:

Finally, use the async thunk in your React component:

```javascript
    // UserComponent.js

    import React, { useEffect } from 'react';
    import { useDispatch, useSelector } from 'react-redux';
    import { fetchUserData } from './userSlice'; // Import your async thunk

    const UserComponent = ({ userId }) => {
    const dispatch = useDispatch();
    const user = useSelector((state) => state.user);

    useEffect(() => {
        dispatch(fetchUserData(userId));
    }, [dispatch, userId]);

    if (user.loading === 'loading') {
        return <div>Loading...</div>;
    }

    if (user.loading === 'failed') {
        return <div>Error: {user.error}</div>;
    }

    return (
        <div>
        <h1>{user.data.name}</h1>
        {/* Render other user data */}
        </div>
    );
    };

    export default UserComponent;
```

This component dispatches the fetchUserData async action on mount and renders different content based on the loading state.

Remember to replace placeholder code with your actual API library and data structures. This example assumes you have an API library with a getUser function that returns a Promise with user data.

## Summary

* You can write reusable "selector" functions to encapsulate reading values from the Redux state
  * Selectors are functions that get the Redux state as an argument, and return some data
* Redux uses plugins called "middleware" to enable async logic
  * The standard async middleware is called redux-thunk, which is included in Redux Toolkit
  * Thunk functions receive dispatch and getState as arguments, and can use those as part of async logic
* You can dispatch additional actions to help track the loading status of an API call
  * The typical pattern is dispatching a "pending" action before the call, then either a "success" containing the data or a "failure" action containing the error
  * Loading state should usually be stored as an enum, like 'idle' | 'loading' | 'succeeded' | 'failed'
* Redux Toolkit has a createAsyncThunk API that dispatches these actions for you
  * createAsyncThunk accepts a "payload creator" callback that should return a Promise, and generates pending/fulfilled/rejected action types automatically
  * Generated action creators like fetchPosts dispatch those actions based on the Promise you return
  * You can listen for these action types in createSlice using the extraReducers field, and update the state in reducers based on those actions.
  * Action creators can be used to automatically fill in the keys of the extraReducers object so the slice knows what actions to listen for.
  * Thunks can return promises. For createAsyncThunk specifically, you can await dispatch(someThunk()).unwrap() to handle the request success or failure at the component level.
